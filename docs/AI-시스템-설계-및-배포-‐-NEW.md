## 1. 모델 배포 개념
### 1.1 Model-in-service vs Model-as-service
AI 모델을 실제 서비스에 배포할 때는 모델을 어떻게 웹 시스템과 통합하여 배포할 것인지를 결정해야 합니다. 
이때 대표적인 방식이 Model-in-service와 Model-as-service입니다.

#### 정의 및 특징 비교
|구분|Model-in-service|Model-as-service|
|---|----------------|----------------|
|개념|모델이 웹서버 내부에 포함되어 함께 배포됨|모델이 웹서버와 분리되어 독립 서비스로 배포됨|
|구성|하나의 통합 서비스  (예: Flask 서버 안에 모델 포함)|모델은 REST API 또는 gRPC로 제공되는 별도 서비스|
|배포 구조|단일 컨테이너 또는 프로세스|두 개 이상의 컨테이너 (예: 웹 서버 + 모델 서버)|
|장점|- 배포 간단<br/>- 기존 인프라 활용 가능<br/>- 개발 초기 단계에 적합|- 유지보수 용이<br/>- 스케일링 유연<br/>- 다양한 애플리케이션과 재사용 가능|
|단점|- 웹서버 리소스를 많이 사용<br/>- 모델 교체 시 전체 재배포 필요|- 초기 구축 복잡<br/>- 지연(latency) 이슈 발생 가능|
|예시|Flask + PyTorch 모델 함께 패키징|FastAPI 서버 ↔ TensorFlow Serving API 연동|

#### 적용 시나리오
|상황|추천 방식|
|---|-------|
|빠르게 데모를 만들고 싶다|Model-in-service|
|모델과 프론트/백엔드를 분리하고 싶다|Model-as-service|
|모델 성능 개선이 자주 있다|Model-as-service|
|리소스가 제한된 환경에서 운영|Model-in-service|

#### 구조 다이어그램

````
[Model-in-service]
┌─────────────┐
│  웹 서버      │
│ + 모델 내장   │
└─────────────┘

[Model-as-service]
┌─────────────┐        ┌─────────────┐
│  웹 서버      │ <───>  │   모델 서버   │
└─────────────┘        └─────────────┘
````

### 1.2 적용 사례
* Model-in-service: 스타트업이 MVP 또는 내부 도구로 Flask/Django 서버에 모델 내장
* Model-as-service: 대기업에서 Kubeflow, TensorFlow Serving, NVIDIA Triton, Docker 등을 이용한 마이크로서비스 구조

---

## 2. AI 모델 배포 프로세스
### 2.1 전체 흐름
1) 데이터 준비 및 전처리 (Preprocessing)
* 원시 데이터를 수집, 정제, 정규화하여 모델 학습에 적합한 형태로 변환
* 예: 결측치 제거, 스케일링, 텍스트 토큰화 등

2) 모델 설계 및 학습 (Training)
* 적절한 알고리즘 선택 (CNN, RNN, Transformer 등)
* 하이퍼파라미터 튜닝 및 교차검증 수행
* 학습 완료 후 모델 파일 저장 (예: .pt, .h5, .pkl)

3) 모델 평가 및 검증 (Validation & Evaluation)
* 테스트 데이터로 모델 성능 확인 (정확도, 재현율, F1 score 등)
* 성능 기준을 만족하면 배포 준비

4) 모델 패키징 (Packaging)
* 모델 파일과 함께 실행 환경(코드, 라이브러리, 설정 파일 등)을 포함
* 일반적으로 Docker, Conda, ONNX, TorchScript 등 활용

5) 서빙 환경 구성 (Serving)
* 모델을 API 형태로 배포 (REST API, gRPC 등)
* 예: Flask + PyTorch, FastAPI + TensorFlow, TorchServe, TensorFlow Serving, NVIDIA Triton

6) 배포 (Deployment)
* 서버/클라우드/엣지 디바이스에 모델 업로드 및 실행
* 방법: Model-in-service / Model-as-service
* 플랫폼: AWS SageMaker, GCP Vertex AI, Azure ML 등

7) 모니터링 및 관리 (Monitoring & Maintenance)
* 응답 속도, 오류율, drift, 모델 정확도 변화 추적
* 모니터링 도구: Prometheus, Grafana, Seldon Core 등

8) 재학습 및 업데이트 (Retraining & Continuous Deployment)
* 피드백 및 새로운 데이터 수집 기반으로 모델 재학습 및 자동 업데이트 (MLOps 도입)

#### 예시: 이미지 분류 모델 배포 (Flask + PyTorch)
````bash
app.py        ← REST API 서버
model.pt      ← 저장된 PyTorch 모델
requirements.txt
Dockerfile    ← 패키징 정의
````

### 2.2 프로세스 순서도
## 프로세스 순서 요약 (간단 순서도)
````
데이터 수집
    ↓
전처리
    ↓
모델 학습 및 저장
    ↓
모델 평가
    ↓
패키징 및 서빙 환경 구성
    ↓
배포 (API or 클라우드)
    ↓
모니터링 및 유지관리
````

## 추가적으로 고려할 사항

|항목|설명|
|---|---|
|버전 관리|모델 버전별 관리 필요 (예: MLflow, DVC)|
|보안|인증, API 제한, 데이터 보호|
|자동화 (MLOps)|CI/CD, 자동 재배포, 파이프라인 관리|


---

## 3. 배포 환경 설계
### 3.1 종속성 관리
*   **예측값은 코드, 모델 가중치, 그리고 디펜던시(종속성)에 따라 결정됩니다**.
*   따라서 웹 서버에 개발 환경과 동일한 디펜던시가 설정되어야 하지만, 이를 항상 보장하는 것은 어려운 작업입니다.
    *   이는 디펜던시를 일관되게 유지하기 어렵고, 업데이트가 어려우며, 심지어 TensorFlow 버전 변경만으로도 모델에 변화가 생길 수 있기 때문입니다.

**종속성 관리의 두 가지 주요 전략**:
#### 1. 모델 표준화 (ONNX)
    *   **ONNX (Open Neural Network Exchange) 라이브러리를 활용합니다**.
    *   **목표**: 언어, 패키지 버전 등과 무관하게 동일한 기능을 제공하여 **환경에 독립적으로 실행 가능한 ML 모델을 개발**하는 것입니다.
    *   **현실적 어려움**:
        *   라이브러리 업데이트 속도가 빨라 변환 과정에서 버그가 자주 발생하며, 이를 해결하는 데 더 많은 작업이 필요할 수 있습니다.
        *   TorchVision과 같은 주변 라이브러리는 지원되지 않는 경우가 많습니다.
        *   특징 변환(feature transformations)과 같은 비-라이브러리 코드에 대해서는 어떻게 해야 할지 고려해야 합니다.

#### 2. 컨테이너 활용 (Docker, BentoML 등)
    *   **도커(Docker)는 OS를 적은 용량/자원으로 가상화하여, 필요한 라이브러리와 애플리케이션만을 구동하는 방식입니다**.
        *   이는 라이브러리, 애플리케이션뿐만 아니라 운영체제(OS)까지 하나의 패키지로 묶는 가상 머신(VM) 방식보다 가볍습니다.
    *   일반적으로 구분 가능한 작업마다 개별 컨테이너가 생성되어 사용됩니다.
        *   예를 들어, 웹 애플리케이션은 웹 서버, 데이터베이스, 작업 큐(Job Queue), 워커(Worker) 등 4개의 컨테이너가 함께 동작할 수 있습니다.
    *   **도커 파일(Dockerfile)**을 통해 컨테이너가 생성되며, 클라우드나 별도 서버에 저장된 **도커 허브(Docker Hub)**를 통해 컨테이너를 공유할 수 있습니다.
    *   **도커는 세 가지 주요 요소로 구성됩니다**:
        *   **클라이언트**: 도커 이미지를 구성하며 로컬 환경에서 여러 명령어를 통해 조작 가능합니다.
        *   **도커 호스트**: 클라이언트의 명령어를 실행하고 이미지/컨테이너를 생성합니다 (서버 또는 로컬 환경 모두 가능).
        *   **레지스트리**: 여러 컨테이너를 저장하고 도커 호스트와 직접 통신합니다.
    *   **강력한 생태계**: 공개된 퍼블릭 도커 허브에 다양한 이미지가 호스팅되어 있으며, 프라이빗 이미지 저장도 가능하여 거의 필수적으로 활용됩니다.
    *   **간소화 도구**: 도커는 입문 난이도가 다소 높은 편이므로, **Cog, BentoML, Truss**와 같은 서비스들은 이러한 과정을 간소화하고 모델 호스팅, 모델 패키징 등 다양한 기능을 제공합니다.

### 3.2 단일장애점(SPOF) 대응

단일장애점(SPOF, Single Point of Failure)은 시스템이나 네트워크에서 특정 구성 요소 하나가 고장 났을 때 전체 시스템이나 서비스가 중단되는 위험 요소를 의미합니다. 즉, 해당 요소의 장애가 전체 시스템의 작동 정지로 이어지는 취약점이 됩니다.
주요 예시로는
	•	하나의 데이터베이스 서버만 사용하는 경우
	•	네트워크 허브, 스위치 같은 핵심 장비가 한 대뿐인 경우
	•	단일 전원 공급장치
	•	하나의 로드 밸런서
등이 있습니다. 이 중 어느 하나라도 문제가 발생하면 전체 서비스가 중단될 수 있기 때문에, SPOF는 고가용성(High Availability)이나 신뢰성을 중요시하는 시스템에서는 반드시 제거 또는 완화가 필요합니다

| 방법 | 내용 |
| --- | --- |
| **이중화(다중화)** | 동일한 기능을 수행하는 시스템을 여러 개 구축 |
| **로드 밸런서** | 여러 서버에 트래픽을 분산 |
| **자동 페일오버** | 문제가 발생하면 자동으로 다른 구성 요소로 전환 |
| **추가 고려 사항** | 모니터링/알림 및 백업/복제 체계 구축 |

---

### 3.3 컨테이너 vs 가상 머신

| 항목 | 컨테이너 | 가상 머신(VM) |
| --- | --- | --- |
| **격리 수준** | 프로세스 수준 (OS 공유) | 운영체제 수준 (완전한 OS 포함) |
| **기동 속도** | 매우 빠름 (초 단위) | 느림 (분 단위일 수 있음) |
| **리소스 사용** | 경량 구조로 효율적 | 많은 메모리 & 저장공간 필요 |
| **배포 용이성** | 이미지 하나로 어디서나 실행 가능 | 환경에 따라 별도 설정 필요 |
| **보안 격리** | 프로세스 단위 격리로 상대적으로 약함 | 완전한 격리로 보안 측면 유리 |

---

## 4. 배포 전략
### 4.1 무중단 배포
|  | Rolling Update | Blue-Green | Canary |
| --- | --- | --- | --- |
| **배포 프로세스** | 애플리케이션 인스턴스를 순차적으로 업데이트하여 전체 시스템의 일부만 동시에 변경 | 두 개의 동일한 환경(블루, 그린)을 준비: 블루는 현재 운영, 그린은 새 버전 배포 | 새로운 버전을 소수 사용자에게만 배포 → 점진적으로 확대 |
| **기본 개념** | - 순차적 업데이트<br>- 가용성 유지<br>- 자동 롤백 | - 블루 환경: 현재 운영<br>- 그린 환경: 새 버전 테스트 | - 카나리 인스턴스: 소수 서버에 배포<br>- 트래픽 비율 점진 증가 |
| **장점** | - 고가용성<br>- **점진적 변경**<br>- 신속 롤백 | - 무중단 서비스<br>- 신속 롤백<br>- **테스트 용이성** | - **위험 최소화**<br>- 신속 롤백<br>- 점진적 배포 |
| **단점** | - 롤백 시 실패 리스크<br>- 서빙/테스트 환경 혼재 | - 두 개 환경 유지 비용 | - 복잡한 라우팅 설정 |

### 4.2 모델 롤아웃

*   **정의**: 이미 배포된 상태의 모델을 **업데이트하고 관리하는 과정**을 의미합니다.
*   이는 모델 서비스를 구축하는 데 필요한 핵심 개념 중 하나입니다.

*   **필수적인 배포 방식**: 새로운 모델을 효율적으로 배포하기 위해서는 다음과 같은 기능들이 가능해야 합니다:
    *   **점진적 배포 (Gradual Rollout)**: 기존 배포 버전에서 새로운 배포 버전으로 트래픽 양을 **점진적으로 증가**시키는 방식입니다.
    *   **즉각적 Rollback (Instant Rollback)**: 문제가 발생한 배포 버전에서 새로운 배포 버전으로 **즉각적인 변경**을 수행하는 방식입니다.
    *   **배포 버전 관리 (Traffic Splitting)**: 두 개의 배포 버전을 동시에 운영하며 **트래픽을 배분**하는 기능입니다.
    *   **파이프라인 배포**: 개발된 파이프라인 플로우를 모델과 함께 배포하는 방식입니다.

*   **구현의 복잡성**: 이러한 롤아웃 기능들은 직접 구현하기 어려운 인프라 문제에 해당하며, 일반적으로 **매니지드 서비스(managed service)** 또는 배포 라이브러리, 인프라 팀의 도움을 통해 모델 배포에 적용됩니다.

---

## 5. 보안 및 운영 고려 사항
### API 인증 및 접근 제어

API 인증은 사용자의 신원을 검증하는 절차로, 대표적으로 OAuth2, OpenID Connect, JWT(JSON Web Token) 등 현대적인 인증 방식을 이용하여 신뢰성을 확보합니다. 인증과 더불어 **접근 제어(Authorization)**는 인증된 사용자에게 역할(Role)이나 권한(Permission)을 기반으로 자원 접근을 제한합니다. 접근 제어 구현 시에는 RBAC(역할기반 접근제어), 최소 권한 원칙(Least Privilege), API 키 관리 등 보안 방안을 적용합니다. 권한 관리와 강력한 인증은 무단 접근, 데이터 노출 및 비정상 행위로부터 중요한 API 자원을 보호하는 핵심 보안 수단입니다[1][2][5][10].

***

### 데이터 암호화

API와 애플리케이션 간 송수신되는 데이터는 반드시 암호화해야 하며, HTTPS(SSL/TLS)를 통한 안전한 채널이 필수입니다. 이를 통해 기밀성(Confidentiality)을 보장하고, 중간자 공격(Man-in-the-Middle) 및 데이터 유출로부터 보호할 수 있습니다. 또한 저장 데이터에도 암호화를 적용하여, 시스템 내 데이터가 도난·유출되더라도 안전할 수 있도록 보호해야 합니다[1][3][4].

***

### 취약점 분석 및 대응

API 환경은 지속적으로 변화하고 있으며, 다양한 공격에 노출될 수 있습니다. 이를 위해 다음과 같은 취약점 분석 및 대응이 필요합니다.
- 정기적인 보안 점검 및 취약점 스캐닝을 수행하여 새로운 위험 요소를 식별함.
- 입력값 검증과 출력값 관리로 인젝션(Injection), XSS 등 일반적 공격에 대응함.
- 실시간 모니터링 및 이상 징후(비정상 접근, 반복적 실패, 트래픽 급증 등)를 탐지함.
- 식별된 취약점에 대해서는 빠른 패치와 정책 개선으로 대응함.
취약점 분석과 대응은 비즈니스 연속성과 데이터 무결성 및 신뢰성을 유지하는 데 매우 중요합니다[2][3][4].

---

출처
[1] API 보안을 위한 10가지 인증 모범 사례 - Apidog https://apidog.com/kr/blog/api-authentication-best-practices-2/
[2] API 보안 체크리스트: 최고 실행 방안, 테스트 및 NIST - F5 https://www.f5.com/ko_kr/company/blog/api-security-checklist
[3] API 보안이란 무엇인가요? https://www.paloaltonetworks.co.kr/cyberpedia/what-is-api-security
[4] API 보안을 강화하는 방법 - Blog - 위베어소프트 https://blog.webaresoft.com/145ba73b-175e-80ca-8a5f-c2bc9b104e7a
[5] API 인증 대 권한 부여 | 알아야 할 보안 차이점 - Apidog https://apidog.com/kr/blog/api-authentication-vs-api-authorization-3/
[6] 11장 API 접근 보안 - velog https://velog.io/@rosesua318/11%EC%9E%A5-API-%EC%A0%91%EA%B7%BC-%EB%B3%B4%EC%95%88
[7] API 인증 방법 · Logto 블로그 https://blog.logto.io/ko/api-authorization-methods
[8] API 보안: API 보호 모범 사례 https://nginxstore.com/blog/api-security/api-%EB%B3%B4%EC%95%88-api-%EB%B3%B4%ED%98%B8-%EB%AA%A8%EB%B2%94-%EC%82%AC%EB%A1%80/
[9] API 의 접근제어 하기 - ePapyrus Tech Net - 이파피루스 https://technet.epapyrus.com/view/docs/streamdocs/5.11.4.0/docs/default-tutorial/pages/auth-main
[10] RESTful API 인증 및 권한 관리: 심화 과정 - subinto의 개발노트 https://subinto.tistory.com/180


---

## 6. 클라우드 플랫폼별 배포

### 하이브리드/온프레미스 배포 고려사항

하이브리드와 온프레미스 배포는 조직이 기존 내부 데이터센터(온프레미스)와 퍼블릭 클라우드 환경을 함께 활용하는 배포 모델입니다. 이 모델들은 각기 다른 장점과 고려사항이 존재하며, 주로 다음과 같은 요소들을 고려해야 합니다.

- **인프라 통합과 관리 복잡성**  
  하이브리드 배포는 프라이빗 클라우드(내부 인프라)와 퍼블릭 클라우드를 네트워크로 연동해 사용하므로, 각각의 인프라 관리와 운영 방식이 달라 통합과 관리의 복잡성이 늘어납니다. 네트워크 연결(예: VPN, 전용 회선)과 모니터링, 보안 정책을 일관되게 적용하는 것이 중요합니다.

- **보안 및 규정 준수**  
  민감한 데이터는 온프레미스나 프라이빗 클라우드에 보관하며, 덜 민감한 워크로드는 퍼블릭 클라우드에 배포하는 경우가 많습니다. 이는 보안, 데이터 주권, 컴플라이언스 요구 사항을 충족하기 위한 전략입니다. 따라서 데이터 암호화, 접근 제어, 보안 감사가 필수적입니다.

- **비용 효율성**  
  초기 비용과 운영 비용 간 균형을 맞추는 것이 중요합니다. 온프레미스는 초기 투자비용과 유지보수 비용이 크지만, 특정 워크로드에 대해 안정적인 운영을 제공합니다. 퍼블릭 클라우드는 유연성과 확장성이 뛰어나지만, 장기적인 비용 최적화가 필요합니다.

- **유연성과 확장성**  
  하이브리드 클라우드는 온프레미스 인프라의 한계를 극복하고, 필요에 따라 퍼블릭 클라우드 리소스를 활용해 확장할 수 있어 비즈니스 변화에 민첩하게 대응할 수 있습니다.

- **데이터 및 애플리케이션 이동성**  
  서로 다른 환경 간에 데이터와 애플리케이션을 원활하게 이동시키기 위한 지원이 중요합니다. 이는 클라우드간 상호 운용성과 이동성, API 호환성 등을 포함합니다.

- **지속적인 모니터링과 최적화**  
  하이브리드 환경은 복잡한 운영 환경을 가지므로, 성능 모니터링, 비용 관리, 보안 상태 점검을 지속적으로 수행하는 체계가 필요합니다.

이처럼 하이브리드/온프레미스 배포는 유연성과 보안을 함께 고려해야 하는 복합적인 환경으로, 조직의 비즈니스 요구사항, 보안 정책, 예산을 면밀히 검토하여 전략적으로 선택하고 관리하는 것이 중요합니다[1][2][5][6].

출처
[1] 클라우드 컴퓨팅에는 어떤 유형이 있나요? - Google Cloud https://cloud.google.com/discover/types-of-cloud-computing?hl=ko
[2] 클라우드 배포 모델 | 개념 - Couchbase https://www.couchbase.com/ko/resources/concepts/cloud-deployment-models/
[3] 클라우드 플랫폼 선택 - AWS https://aws.amazon.com/ko/choosing-a-cloud-platform/
[4] 5가지 클라우드 배포 모델:차이점 알아보기 https://ko.mfgrobots.com/iiot/cloud/1008031200.html
[5] 클라우드 배포 모델이란? 적합한 클라우드 선택 - PayPro Global https://payproglobal.com/ko/%EB%8B%B5%EB%B3%80/%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%B0%B0%ED%8F%AC-%EB%AA%A8%EB%8D%B8%EC%9D%B4%EB%9E%80/
[6] SaaS, PaaS, IaaS 간 비교 – 클라우드 컴퓨팅 유형 - AWS https://aws.amazon.com/ko/types-of-cloud-computing/
[7] 퍼블릭 클라우드 배포 모델이란? 유형 및 예 - PayPro Global https://payproglobal.com/ko/%EB%8B%B5%EB%B3%80/%ED%8D%BC%EB%B8%94%EB%A6%AD-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C-%EB%B0%B0%ED%8F%AC-%EB%AA%A8%EB%8D%B8%EC%9D%B4%EB%9E%80/
[8] Google Cloud 배포 아키타입 비교 분석 | Cloud Architecture Center https://cloud.google.com/architecture/deployment-archetypes/comparison?hl=ko
[9] 클라우드 컴퓨팅의 유형 - Red Hat https://www.redhat.com/ko/topics/cloud-computing/public-cloud-vs-private-cloud-and-hybrid-cloud
[10] 클라우드 서비스 비교 - SaaS PaaS IaaS 차이 - Elice https://elice.io/ko/newsroom/saas_paas_iaas

